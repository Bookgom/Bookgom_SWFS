2022-01-30~02-5 (2주차)
<hr />
<h2>제 2장 디지털데이터</h2>
<hr />

<h3>이진수와 16진수</h3>
<dl>
   <dt>1. 이진수</dt>
	<dd>- 디지털 데이터는 '0'또는 '1'로 표현하는 이진수를 기본적으로 사용한다.</dd>
	<dd>- 메모리, 하드디스크 저장장치, 네트워크 장비 등 모든 디지털 시스템에는 이진수를 사용하여 데이터를 저장하고 처리</dd>
             <dd>ex) 010111100100001...</dd>

   <dt>2. 16진수</dt>
	<dd>- 디지털 데이터는 2진수를 사용하지만 화면에 출력하거나 처리할 때 비효율적이다.</dd>
	<dd>- 간단하고 편리하게 사용하기 위해 4 Bit 단위로 묶어서 표현한다. </dd>
</dl>

<h3>문자</h3>
<dl>
   <dt>1. 아스키코드</dt>
	<dd>1. 7비트로 구성된 128 종의 기호를 정한 것으로, 1바이트로 하나의 문자를 표현한다.</dd>
	<dd>2. 128 종의 기호 = 제어 부호 33자 + 그래픽 기호 33자 + 숫자 10자(0~9) + 알파벳 대소문자 52자</dd>
	<dd>3. 영문을 표기하는 대부분의 시스템에서 사용한다.</dd>
	<dd>4. 제어 부호는 통신의 시작과 종료, 라인 피드 등을 표시 할 수 있기 때문에 데이터 통신에도 이용한다.</dd>

   <dt>2. UTF-8</dt>
	<dd>1. 한 문자를 나타내기 위해 1바이트에서 4바이트 까지를 사용한다.</dd>
	<dd>2. 아스키 문자들은 UTF-8에서 1바이트만으로 표시한다.</dd>
	<dd>3. 4바이트로 표현되는 문자는 모두 기본 다국어 평면의 유니코드 문자로, 한글은 보통 3바이트로 표현된다.</dd>
	<dd>4. UTF-8의 성질</dd>
	<dd>  - 1바이트로 표시된 문자의 최상위 비트는 항상 0</dd>
	<dd>  - 2바이트 이상으로 표시된 문자의 경우, 첫 바이트의 상위 비트들이 그 문자를 표시하는데 필요한 바이트 수를 결정한다.</dd>
	<dd>    ex) 2 바이트는 110으로 시작, 3바이트는 1110으로 시작.</dd>
	<dd>  - 첫 바이트가 아닌 나머지 바이트들은 상위 2비트가 항상 10</dd>
</dl>

<hr />
<h3>실습01. 저장데이터 정보 분석</h3>
<hr />
사용프로그램 = HxD

<h4>실습 01_1. 텍스트 파일</h4>
<ul>
   <ol start="1">
	<li>123.txt 생성</li>
	   <dl>
		<dd>메모장 프로그램을 실행하여 숫자 123 값을 입력하고 123.txt 파일명으로 저장한다.</dd>
		<dd><img src="https://user-images.githubusercontent.com/92700920/152545873-4aef058c-0efa-4d81-9e10-1465e8958a44.PNG" width="300"></dd>
	   </dl>
   </ol>

   <ol start="2">		
	<li>abc.txt</li>
	   <dl>
		<dd>메모장 프로그램을 실행하여 문자 a, b, c를 입력하고 abc.txt 파일명으로 저장한다.</dd>
		<dd><img src="https://user-images.githubusercontent.com/92700920/152546865-6abfefbf-652d-4fdd-afe1-d9bdad9ef845.PNG" width="300"></dd>
	   </dl>
   </ol>

   <ol start="3">
	<li>123.txt에 저장된 데이터</li>
	   <dl>
		<dd>- HxD 프로그램으로 123.txt 파일을 열어서 저장된 데이터 내용을 확인하면 아스키코드 값이 3바이트로 저장되어 있는 것으로 확인된다.</dd>
		<dd>-  1의 아스키 코드 > 31   |   2의 아스키 코드 > 32   |   3의 아스키 코드 > 33</dd>
		<dd><img src="https://user-images.githubusercontent.com/92700920/152547846-4031b307-f9b6-47f7-b95a-2672dd7f380d.PNG" width="350"></dd>
	   </dl>
   </ol>

   <ol start="4">
	<li>abc.txt.에 저장된 데이터</li>
	   <dl>	
		<dd>- HxD 프로그램으로 abc.txt 파일을 열어서 저장도니 데이터 내용을 확인하면 아스키코드 값이 31ㅏ이트로 저장되어 있는 것으로 확인된다.</dd>
		<dd>-  a의 아스키 코드 > 61   |   b의 아스키 코드 > 62   |   c의 아스키 코드 > 63</dd>
		<dd><img src="https://user-images.githubusercontent.com/92700920/152548348-9581761a-ee86-4033-b0bc-cf7658bf29ee.PNG" width="350"></dd>
	   </dl>
   </ol>
</ul>
<hr>
실습을 통해 알게 된 점
<hr>

<strong>알게 된 점</strong>:  파일과 아스키코드 사이에서 어떤식으로 저장이 되고 보이는지 알게 되었다.

<hr>

<h4>실습01_2. 바이너리 파일</h4>

바이너리 파일은 이진 파일로, 텍스트 파일이 아닌 파일이며,
컴퓨터가 저장 및 처리를 목적으로 이진 형식으로 인코딩한 데이터를 포함하는 파일을 의미한다.

바이너리 파일 종류는 이미지, 동영상, 한글문서 파일 등이 있는데
이 파일을 텍스트로 열어보면 글자가 깨진 것처럼 보여진다.
<ul>
   <ol start="1">
	<li>바이너리 파일 생성</li>
	   <dl>
		<dd>파이썬 프로그램을 활용하여 123.bin과 abc.bin 바이너리 파일을 생성한다.</dd>
		<dd><img src="https://user-images.githubusercontent.com/92700920/152553635-fa4ba8b3-1d30-46bc-acda-72f24a86ea5a.PNG" width="300"></dd>
	   </dl>
   </ol>

   <ol start="2">		
	<li>123.bin 파일 저장 데이터</li>
	   <dl>
		<dd>HxD 프로그램으로 123.bin 파일을 열어서 데이터를 확인하면 7B 값 1바이트가 저장되어 있는 것으로 확인된다.</dd>
		<dd>123의 아스키 코드 값 > 7B
		<dd><img src="https://user-images.githubusercontent.com/92700920/152553773-596f1381-f1bd-434d-b5b8-4bbed86bcf48.PNG" width="350"></dd>
		<dd>위 처럼 텍스트 파일은 123 값을 저장 시 3바이트가 필요하다면, 바이너리 파일로 저장할 경우는 1 바이트가 필요하여 파일 전송 시 효율성이 좋다.</dd>
	   </dl>
   </ol>

   <ol start="3">
	<li>abc.bin 파일 저장 데이터</li>
	   <dl>
		<dd>HxD 프로그램으로 abc.bin 파일을 열어서 저장된 데이터 내용을 확인하면 아스키코드 값이 61, 62, 63 값이 3바이트로 저장되어 있는 것으로 확인된다.</dd>
		<dd> a의 아스키 코드 > 61   |   b의 아스키 코드 > 62   |   c의 아스키 코드 > 63</dd>
		<dd><img src="https://user-images.githubusercontent.com/92700920/152556977-a736b434-13b4-4a9b-a80e-5463ea0e400e.PNG" width="350"></dd>
	   </dl>
   </ol>
</ul>
<hr>
실습을 통해 알게 된 점
<hr>

<strong>알게 된 점</strong>: 바이너리 파일을 만들어 확인해 보니 확실이 바이트가 줄어있는 것을 확인하여 효율성을 느꼈는데, 문자로 된 파일인 경우 그대로 인 결과를 보고 바이너리 파일이라는 것에 대한 이해도가 높아진 것 같다.

<hr/>
<h3>빅엔디언과 리틀엔디언</h3>

컴퓨터에서 데이터를 저장하면 컴퓨터 종류 등에 따라 데이터를 저장하는 방식이 다른데,
여기서 대표적으로 빅엔디언과 리틀엔디언으로 나눌 수 있다.
<dl>
   <dt>1. 빅엔디언</dt>
	<dd>1. 바이트 열에서 가장 큰 값이 먼저 저장되는 순서이다.</dd>
	<dd>2. IBM 370 컴퓨터와 RISC 기반 컴퓨터 등은 빅엔디언을 사용한다.</dd>
	<dd>3. 빅엔디언 방식으로 저장되는 데이터는 아래의 데이터를 0x7DB4로 읽는다.</dd>
	<dd><img src="https://user-images.githubusercontent.com/92700920/152558512-c5ca7fca-ea35-4218-9959-6368bc7290cc.PNG" width="400"></dd>

   <dt>2. 리틀엔디언</dt>
	<dd>1. 바이트 열에서 가장 작은 값을 먼저 저장한다.</dd>
	<dd>2. 인텔프로세서 등의 컴퓨터는 리틀엔디언을 사용한다.</dd>
	<dd>3. 리틀엔지어 저장방식은 아래의 데이터를 0xB47D로 읽는다.</dd>
	<dd><img src="https://user-images.githubusercontent.com/92700920/152558663-fe3a025b-ddbb-417a-8046-4e331cc708ba.PNG" width="400"></dd>
</dl>

<hr/>
<h3>시간정보의 표현</h3>

컴퓨터 포렌식에서 시간과 날짜는 중요한 정보이며, 이 정보가 없다면 디지털 증거는 의미를 잃어버렸다고도 할 수 있다.
이 때, 컴퓨터는 어떤 식으로 시간을 생성하고 관리하는지에 대하여 공부할 것이다.
<dl>
   <dt>1. 시스템 시간</dt>
	<dd>윈도우 시스템은 부팅시 컴퓨터의 마더보드(메인보드)의 리튬배터리에 연결된 RTC(Real-Time Clock)으로부터 현재 시간을 가져오거나 인터넷 서버와 동기화하여
시스템의 시간을 구성한 후 모니터 오른쪽 아래에 시스템 시간을 출력한다.</dd>
	
   <dt>2. 표준시간대</dt>
	<dd>- 지구의 자전으로 나라마다 밤과 낮이 다르다.</dd>
	<dd>- 각 나라에서 사용하는 표준사간대는 UTC(Coordinated Universal Time)이다.</dd>
	<dd>- 한국의 표준시간대는 한국 표준시(KST, UTC+9)로 UTC 기준시간 보다 9시간 빠르다.</dd>

   <dt>3. 파일시스템 시간</dt>
	<dd>가. time_t</dd>
	<dd>   - 유닉스 운영체제에서 시간을 저장하는 표준 형식 </dd>
	<dd>   - 시간 형식을 4바이트(32비트)로 저장</dd>
	<dd>나. time64_t</dd>
	<dd>   - time_t의 문제 (1. 정수형을 사용하는 경우/ 2. 한계치를 넘으면 초기화)등을 보완하기 위하여 사용</dd>
	<dd>   - time64_t를 사용하는 경우 운영체제 또한 64비트를 사용하도록 time_t의 정의를 변경</dd>
	<dd>다. FILETIME 시간 포맷</dd>
	<dd>   - 윈도우 32비트에서 주로 사용하는 시간 정보 저장 형식이다.</dd>
	<dd>   - 1601년 1월 1일 자정 이후 100나노 초 간겨의 숫자를 저장</dd>
	<dd>   - 구조체는 8바이트(64비트)이며, 날짜와 시간을 각 4바이트에 저장한다.</dd>
	<dd>   - FILETIME을 time_t로 변환하는 공식 > time_t = (FILETIME -0x19DB1DED53E8000) / 10000000</dd>
	<dd>라. 파일 시스템에서의 시간</dd>
	<dd>   - FAT32 파일시스템</dd>
	<dd>     FAT32 파일시스템은 생성시간, 수정시간, 접근시간이 1980년 1월 1일부터 2107년 12월 31일까지 기록된다.</dd>
	<dd>   - NTFS 파일 시스템</dd>
	<dd>     NTFS는 8바이트의 고정길이로 1601년 1월 1일을 기준으로하고 그 이후의 누적시간을 연, 월, 일, 시, 분, 초 단위로 환산한 후 기준 시에 더하는 방식 사용한다.</dd>
</dl>

<hr>
<h3>실습02. 파일 시간 정보 분석</h3>
<hr />
사용프로그램 = DCode
*실습 주의 사항:  프로그램 사용 시 우리나라 시간으로 변환해야 하니 UTC+9가 맞는지 확인하기!*

<h4>실습02_1. 아래의 시간정보를 Date&Time으로 변환하시오.</h4>
<ul>
   <ol start="1">
	<li>빅엔디언 형식으로 저장된 값을 Windows 64bit 타임으로 변환</li>
	   <dl>
		<dd>형식: 빅엔디언, windows 64bit 타임 / 값: 01D0E15F31D20303</dd>
		<dd><img src="https://user-images.githubusercontent.com/92700920/152566782-a6af826e-43fe-4d77-8e25-4f3f1fb00ad4.PNG" width="400"></dd>
	   </dl>
   </ol>

   <ol start="2">		
	<li>리틀엔디언 형식으로 저장도니 값을 Windows 64bit 타임으로 변환</li>
	   <dl>
		<dd>형식: 리틀엔디언, windows 64bit 타임 / 값: FF03D2315FE1C701</dd>
		<dd><img src="https://user-images.githubusercontent.com/92700920/152566881-940cda2a-488a-4d0b-b331-8d4994cee9bb.PNG" width="400"></dd>
	   </dl>
   </ol>
</ul>

<h4>실습02_2. 윈도우 파일시스템의 일부정보를 이미지 파일로 저장한 내용이다. 빨간색 사각형으로 표시한 시간 정보 값을 변환하면?</h4>
<ul>
   <ol start="1">
	<li>문제에서 나온 빨간색 사각형 안의 시간 정보</li>
	   <dl>
		<dd>값: CF22CA4BE3BCD301</dd>
		<dd><img src="https://user-images.githubusercontent.com/92700920/152565353-fddf5323-2174-4c9f-9ba2-31efaaa9c9b4.PNG" width="400"></dd>
	   </dl>
   </ol>
   
   <ol start="2">
	<li>결과</li>
	   <dl>
		<dd>값을 변환하여 나온 Date&Time: Fri, 16 March 2018 13:57:33 +0900</dd>
		<dd><img src="https://user-images.githubusercontent.com/92700920/152566651-c990e7e7-365d-45dc-be3a-0951f78f22d0.PNG" width="400"></dd>
	   </dl>
   </ol>
</ul>
<hr>
실습을 통해 알게 된 점
<hr>

<strong>알게 된 점</strong>: 시간이 어떤식으로 표현이 되는지와 함께, 프로그램 사용 시 우리나라는 UTC+9이니 이 대한민국 표준으로 설정을 해야 한다는 것을 알았다.

<hr/>

<h3>데이터 인코딩</h3>
<dl>
   <dt>1. 데이터 인코딩</dt>
	<dd>숫자, 문자, 시간 등의 데이터는 원본 그대로의 형태로 저장될 수 있지만, 다양한 인코딩 알고리즘에 따라 특수한 형태의 데이터로 변환되며, 이러한 인코딩 방식 중 많이 사용되는 Base 64에 대해서 알아볼 것이다.</dd>

   <dt>2. Base 64</dt>
	<dd>1. 임의의 바이너리 데이터를 64개의 아스키 문자의 조합으로 표현된다. </dd>
	<dd>2. 알파벳 대소문자와 숫자, 그리고 +, / 기호 64개로 이루어 진다.</dd>
	<dd>3. 이 base 64 인코딩 웹, 이메일 S/W 바이너리 데이터 전송 등에 널리 사용된다.</dd>
	<dd><strong>Base64 인코딩 과정</strong></dd>
	<dd> 문자 > 아스키 코드 변환 > 2진수 변환 > 6비트로 나눔> 10진수 변환> Base 64 문자표 변환 > 끝</dd>
</dl>

<hr>
<h3>실습03. 데이터 인코딩</h3>
<hr />

<h4>실습03_1. 아래의 문자열을 Base64로 인코딩 방식으로 변환하시오.</h4>
<ul>
   <ol start="1">
	<li>변환 문자열: Get</li>
	   <dl>
		<dd> 문자 > 아스키 코드 변환 > 2진수 변환 > 6비트로 나눔> 10진수 변환> Base 64 문자표 변환 > 끝</dd>
		<dd>Get > 47 65 74 > 0010 1111 0100 0001 0100 1010 > 001011 110100 000101 001010 > 11 52 5 10 > L 0 F K > L0FK</dd>
	   </dl>
   </ol>

   <ol start="2">		
	<li>변환 문자열: Forensic</li>
	   <dl>
		<dd> 문자 > 아스키 코드 변환 > 2진수 변환 > 6비트로 나눔> 10진수 변환> Base 64 문자표 변환 > 끝</dd>
		<dd>Forensic > 46 6F 72 65 6E 73 69 63 > 0100 0110 0110 1111 0111 0010 0110 0101 0110 1110 0111 0011 0110 1001 0110 0011</dd>
		<dd>> 010001 100110 11101 110010 011001 010110 111001 110011 011010 010110 0011 > 17 38 29 50 25 22 57 51 26 22 3</dd>
		<dd>> R m d y Z W 5 z a W D > RmdyZW5zaWD
	   </dl>
   </ol>
</ul>

<hr>
실습을 통해 알게 된 점
<hr>

<strong>알게 된 점</strong>: Base 64의 인코딩 방식을 하나하나 해보며 어떤식으로 진행이 되는지 알아갔다.
